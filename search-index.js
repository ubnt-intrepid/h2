var N = null;var searchIndex = {};
searchIndex["h2"]={"doc":"An asynchronous, HTTP/2.0 server and client implementation.","items":[[3,"Error","h2","Represents HTTP/2.0 operation errors.",N,N],[3,"Reason","","HTTP/2.0 error codes.",N,N],[3,"SendStream","","Sends the body stream and trailers to the remote peer.",N,N],[3,"StreamId","","A stream identifier, as described in [Section 5.1.1] of RFC 7540.",N,N],[3,"RecvStream","","Receives the body stream and trailers from the remote peer.",N,N],[3,"ReleaseCapacity","","A handle to release window capacity to a remote stream.",N,N],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"reason","","If the error was caused by the remote peer, the error reason.",0,[[["self"]],["option",["reason"]]]],[11,"is_io","","Returns the true if the error is an io::Error",0,[[["self"]],["bool"]]],[11,"get_io","","Returns the error if the error is an io::Error",0,[[["self"]],["option",["error"]]]],[11,"into_io","","Returns the error if the error is an io::Error",0,[[["self"]],["option",["error"]]]],[11,"from","","",0,[[["error"]],["error"]]],[11,"from","","",0,[[["reason"]],["error"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"description","","",0,[[["self"]],["str"]]],[11,"eq","","",1,[[["self"],["reason"]],["bool"]]],[11,"ne","","",1,[[["self"],["reason"]],["bool"]]],[11,"clone","","",1,[[["self"]],["reason"]]],[18,"NO_ERROR","","The associated condition is not a result of an error.",1,N],[18,"PROTOCOL_ERROR","","The endpoint detected an unspecific protocol error.",1,N],[18,"INTERNAL_ERROR","","The endpoint encountered an unexpected internal error.",1,N],[18,"FLOW_CONTROL_ERROR","","The endpoint detected that its peer violated the flow-control protocol.",1,N],[18,"SETTINGS_TIMEOUT","","The endpoint sent a SETTINGS frame but did not receive a response in a timely manner.",1,N],[18,"STREAM_CLOSED","","The endpoint received a frame after a stream was half-closed.",1,N],[18,"FRAME_SIZE_ERROR","","The endpoint received a frame with an invalid size.",1,N],[18,"REFUSED_STREAM","","The endpoint refused the stream prior to performing any application processing.",1,N],[18,"CANCEL","","Used by the endpoint to indicate that the stream is no longer needed.",1,N],[18,"COMPRESSION_ERROR","","The endpoint is unable to maintain the header compression context for the connection.",1,N],[18,"CONNECT_ERROR","","The connection established in response to a CONNECT request was reset or abnormally closed.",1,N],[18,"ENHANCE_YOUR_CALM","","The endpoint detected that its peer is exhibiting a behavior that might be generating excessive load.",1,N],[18,"INADEQUATE_SECURITY","","The underlying transport has properties that do not meet minimum security requirements.",1,N],[18,"HTTP_1_1_REQUIRED","","The endpoint requires that HTTP/1.1 be used instead of HTTP/2.",1,N],[11,"description","","Get a string description of the error code.",1,[[["self"]],["str"]]],[11,"from","","",1,[[["u32"]],["reason"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[0,"client","","Client implementation of the HTTP/2.0 protocol.",N,N],[3,"Handshake","h2::client","Performs the HTTP/2.0 connection handshake.",N,N],[3,"SendRequest","","Initializes new HTTP/2.0 streams on a connection by sending a request.",N,N],[3,"ReadySendRequest","","Returns a `SendRequest` instance once it is ready to send at least one request.",N,N],[3,"Connection","","Manages all state associated with an HTTP/2.0 client connection.",N,N],[3,"ResponseFuture","","A future of an HTTP response.",N,N],[3,"Builder","","Builds client connections with custom configuration values.",N,N],[5,"handshake","","Creates a new configured HTTP/2.0 client with default configuration values backed by `io`.",N,[[["t"]],["handshake",["bytes"]]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"clone","","",4,[[["self"]],["builder"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"poll_ready","","Returns `Ready` when the connection can initialize a new HTTP/2.0 stream.",5,[[["self"]],["poll",["error"]]]],[11,"ready","","Consumes `self`, returning a future that returns `self` back once it is ready to send a request.",5,[[["self"]],["readysendrequest"]]],[11,"send_request","","Sends a HTTP/2.0 request to the server.",5,[[["self"],["request"],["bool"]],["result",["error"]]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"clone","","",5,[[["self"]],["self"]]],[11,"poll","","",2,[[["self"]],["poll"]]],[11,"new","","Returns a new client builder instance initialized with default configuration values.",4,[[],["builder"]]],[11,"initial_window_size","","Indicates the initial window size (in octets) for stream-level flow control for received data.",4,[[["self"],["u32"]],["self"]]],[11,"initial_connection_window_size","","Indicates the initial window size (in octets) for connection-level flow control for received data.",4,[[["self"],["u32"]],["self"]]],[11,"max_frame_size","","Indicates the size (in octets) of the largest HTTP/2.0 frame payload that the configured client is able to accept.",4,[[["self"],["u32"]],["self"]]],[11,"max_header_list_size","","Sets the max size of received header frames.",4,[[["self"],["u32"]],["self"]]],[11,"max_concurrent_streams","","Sets the maximum number of concurrent streams.",4,[[["self"],["u32"]],["self"]]],[11,"initial_max_send_streams","","Sets the initial maximum of locally initiated (send) streams.",4,[[["self"],["usize"]],["self"]]],[11,"max_concurrent_reset_streams","","Sets the maximum number of concurrent locally reset streams.",4,[[["self"],["usize"]],["self"]]],[11,"reset_stream_duration","","Sets the duration to remember locally reset streams.",4,[[["self"],["duration"]],["self"]]],[11,"enable_push","","Enables or disables server push promises.",4,[[["self"],["bool"]],["self"]]],[11,"handshake","","Creates a new configured HTTP/2.0 client backed by `io`.",4,[[["self"],["t"]],["handshake"]]],[11,"default","","",4,[[],["builder"]]],[11,"set_target_window_size","","Sets the target window size for the whole connection.",6,[[["self"],["u32"]]]],[11,"poll","","",6,[[["self"]],["poll",["error"]]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"poll","","",7,[[["self"]],["poll"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"poll","","",3,[[["self"]],["poll"]]],[11,"stream_id","","Returns the stream ID of the response stream.",3,[[["self"]],["streamid"]]],[0,"server","h2","Server implementation of the HTTP/2.0 protocol.",N,N],[3,"Handshake","h2::server","In progress HTTP/2.0 connection handshake future.",N,N],[3,"Connection","","Accepts inbound HTTP/2.0 streams on a connection.",N,N],[3,"Builder","","Builds server connections with custom configuration values.",N,N],[3,"SendResponse","","Send a response back to the client",N,N],[5,"handshake","","Creates a new configured HTTP/2.0 server with default configuration values backed by `io`.",N,[[["t"]],["handshake",["bytes"]]]],[11,"clone","","",8,[[["self"]],["builder"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"set_target_window_size","","Sets the target window size for the whole connection.",10,[[["self"],["u32"]]]],[11,"poll_close","","Returns `Ready` when the underlying connection has closed.",10,[[["self"]],["poll",["error"]]]],[11,"abrupt_shutdown","","Sets the connection to a GOAWAY state.",10,[[["self"],["reason"]]]],[11,"graceful_shutdown","","Starts a [graceful shutdown][1] process.",10,[[["self"]]]],[11,"poll","","",10,[[["self"]],["poll",["option","error"]]]],[11,"fmt","","",10,[[["self"],["formatter"]],["result"]]],[11,"new","","Returns a new server builder instance initialized with default configuration values.",8,[[],["builder"]]],[11,"initial_window_size","","Indicates the initial window size (in octets) for stream-level flow control for received data.",8,[[["self"],["u32"]],["self"]]],[11,"initial_connection_window_size","","Indicates the initial window size (in octets) for connection-level flow control for received data.",8,[[["self"],["u32"]],["self"]]],[11,"max_frame_size","","Indicates the size (in octets) of the largest HTTP/2.0 frame payload that the configured server is able to accept.",8,[[["self"],["u32"]],["self"]]],[11,"max_header_list_size","","Sets the max size of received header frames.",8,[[["self"],["u32"]],["self"]]],[11,"max_concurrent_streams","","Sets the maximum number of concurrent streams.",8,[[["self"],["u32"]],["self"]]],[11,"max_concurrent_reset_streams","","Sets the maximum number of concurrent locally reset streams.",8,[[["self"],["usize"]],["self"]]],[11,"reset_stream_duration","","Sets the maximum number of concurrent locally reset streams.",8,[[["self"],["duration"]],["self"]]],[11,"handshake","","Creates a new configured HTTP/2.0 server backed by `io`.",8,[[["self"],["t"]],["handshake"]]],[11,"default","","",8,[[],["builder"]]],[11,"send_response","","Send a response to a client request.",9,[[["self"],["response"],["bool"]],["result",["sendstream","error"]]]],[11,"send_reset","","Send a stream reset to the peer.",9,[[["self"],["reason"]]]],[11,"poll_reset","","Polls to be notified when the client resets this stream.",9,[[["self"]],["poll",["reason","error"]]]],[11,"stream_id","","Returns the stream ID of the response stream.",9,[[["self"]],["streamid"]]],[11,"poll","","",11,[[["self"]],["poll"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"fmt","h2","",12,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",13,[[["self"],["formatter"]],["result"]]],[11,"clone","","",13,[[["self"]],["streamid"]]],[11,"eq","","",13,[[["self"],["streamid"]],["bool"]]],[11,"ne","","",13,[[["self"],["streamid"]],["bool"]]],[11,"hash","","",13,N],[11,"fmt","","",14,[[["self"],["formatter"]],["result"]]],[11,"reserve_capacity","","Requests capacity to send data.",12,[[["self"],["usize"]]]],[11,"capacity","","Returns the stream's current send capacity.",12,[[["self"]],["usize"]]],[11,"poll_capacity","","Requests to be notified when the stream's capacity increases.",12,[[["self"]],["poll",["option","error"]]]],[11,"send_data","","Sends a single data frame to the remote peer.",12,[[["self"],["b"],["bool"]],["result",["error"]]]],[11,"send_trailers","","Sends trailers to the remote peer.",12,[[["self"],["headermap"]],["result",["error"]]]],[11,"send_reset","","Resets the stream.",12,[[["self"],["reason"]]]],[11,"poll_reset","","Polls to be notified when the client resets this stream.",12,[[["self"]],["poll",["reason","error"]]]],[11,"stream_id","","Returns the stream ID of this `SendStream`.",12,[[["self"]],["streamid"]]],[11,"is_end_stream","","Returns true if the receive half has reached the end of stream.",15,[[["self"]],["bool"]]],[11,"release_capacity","","Get a mutable reference to this streams `ReleaseCapacity`.",15,[[["self"]],["releasecapacity"]]],[11,"poll_trailers","","Returns received trailers.",15,[[["self"]],["poll",["option","error"]]]],[11,"stream_id","","Returns the stream ID of this stream.",15,[[["self"]],["streamid"]]],[11,"poll","","",15,[[["self"]],["poll",["option"]]]],[11,"fmt","","",15,[[["self"],["formatter"]],["result"]]],[11,"stream_id","","Returns the stream ID of the stream whose capacity will be released by this `ReleaseCapacity`.",14,[[["self"]],["streamid"]]],[11,"release_capacity","","Release window capacity back to remote stream.",14,[[["self"],["usize"]],["result",["error"]]]],[11,"clone","","",14,[[["self"]],["self"]]]],"paths":[[3,"Error"],[3,"Reason"],[3,"ReadySendRequest"],[3,"ResponseFuture"],[3,"Builder"],[3,"SendRequest"],[3,"Connection"],[3,"Handshake"],[3,"Builder"],[3,"SendResponse"],[3,"Connection"],[3,"Handshake"],[3,"SendStream"],[3,"StreamId"],[3,"ReleaseCapacity"],[3,"RecvStream"]]};
initSearch(searchIndex);
